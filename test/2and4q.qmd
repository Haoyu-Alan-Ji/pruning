---
title: "My document"
author: "Haoyu Ji-jih20"
format: 
  html:
    self-contained: true
date: today
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
setwd(here::here())
```

```{r pkgs, message = FALSE, warning=FALSE}
library(Matrix)
library(ape)
library(tidyverse); theme_set(theme_bw())
library(waldo)
library(expm)
library(RTMB)
library(numDeriv) ## for testing gradients
library(microbenchmark)
```

```{r seed}
set.seed(427)
```

```{r primate-tree1}
load("../data/primates.rda")
p1 <- reorder(primate.tree1, "pruningwise")
plot(p1)
tiplabels()
nodelabels()
```

## with RTMB
```{r qtemp}
## put indices in corresponding to allowed transitions
states <- c("(0,0)", "(0,1)", "(1,0)", "(1,1)")
Q_template4 <- matrix(0, 4, 4,
                     dimnames = list(states, states))
allowed <- matrix(c(2,1,
                    3,1,
                    1,2,
                    4,2,
                    1,3,
                    4,3,
                    3,4,
                    2,4),
                  ncol = 2,
                  byrow = TRUE)
Q_template4[allowed] <- 1:8
image(Matrix(Q_template4))

trans_rates <- abs(rnorm(8))
Q_cur <- Q_template4

## start likelihood calculation here ...
Q_cur[Q_cur!=0] <- trans_rates  ## fill in transition rate values
diag(Q_cur) <- -rowSums(Q_cur) ## set diagonal
## ... now compute the log-likelihood using this Q ...
image(Matrix(Q_cur))

rate.mat <- matrix(c(NA, 1, NA, 2, NA, 3, NA, 3, NA), 3, 3)
```

```{r prune-nll}
## TMBdata should contain:
## * d (dimension/number of states)
## * Q_template (0 in disallowed transitions, i = 1, ..., n in allowed transitions -
##   mapping between transition rates and transition matrix elements)
## * tree (already reordered pruningwise)
## * trait_value for each tip (coded as a vector; not yet allowing
##   for ambiguity/uncertainty in trait values)
## (could we have data on some interior nodes?)

## construct template for 2x2
## right now, now constraints on the transition matrix (i.e
## all elements can be non-zero)

# ntri = 3
# as.integer(round(0.5 * (1 + sqrt(1 + 8 * ntri))))
# ## from length of (strictly) lower triangle, compute dimension of matrix
# get_matdim <- function(ntri) {
# as.integer(round(0.5 * (1 + sqrt(1 + 8 * ntri))))
# }
#d*(d-1)/2 == n solve

prune_nll <- function(pars) {
  ## allow sub-assignment, i.e. assignment to a particular row of a matrix
  ## https://groups.google.com/g/tmb-users/c/HlPqkfcCa1g
  "[<-" <- ADoverload("[<-")
  "c" <- ADoverload("c")
  "diag<-" <- ADoverload("diag<-")
  getAll(pars, TMBdata)
  Q <- Q_template
  Q[Q!=0] <- trans_rates[Q[Q!=0]] ## fill in trans rate elements
  diag(Q) <- -1*rowSums(Q)
  liks <- matrix(NA, nrow = Ntip(tree) + tree$Nnode, ncol = d)
  ntips <- length(trait_values)
  liks[1:ntips,] <- 0
  ## could do this with matrix indexing but this is easier to understand
  for (i in 1:nrow(liks)) {
    liks[i, trait_values[i]] <- 1
  }
  comp <- numeric(nrow(liks))
  anc <- unique(tree$edge[, 1])
  for (i in anc) {
    desRows <- which(tree$edge[, 1] == i)
    desNodes <- tree$edge[desRows, 2]
    v <- 1
    for (j in seq_along(desRows)) {
      t <- tree$edge.length[desRows[j]]
      ## need Matrix::expm , then drop() to convert back to a vector
      P <- Matrix::expm(Q * t)
      v <- drop(v * (P %*% liks[desNodes[j], ]))
    }
    comp[i] <- sum(v)
    liks[i, ] <- v / comp[i]
    ## n.b. these numbers won't make sense in AD mode!
  }
  TIPS <- 1:Ntip(tree)
  root <- Ntip(tree) + 1
  root.p <- rep(1/d, d)  ## assume flat prior at root
  neg_loglik <- -1*(sum(log(comp[-TIPS])) + log(sum(root.p * liks[root, ])))
  return(neg_loglik)
}
```

```{r test-prune-nll}
## test
pars <- list(trans_rates=c(1.2, 0.5))
n <- length(pars$trans_rates)
factors <- which(n %% 1:n == 0)
dim <- factors[length(factors)/2 + 1]
Q <- matrix(0, dim, dim)
non_diag <- (row(Q) != col(Q))
Q[non_diag] <- pars$trans_rates ## fill in off-diagonals
diag(Q) <- -1*rowSums(Q)

Q_template <- matrix(0, dim, dim)
non_diag <- (row(Q) != col(Q))
nrates <- sum(non_diag)
Q_template[non_diag] <- seq(nrates)

traits <- with(as.data.frame(primate.discrete2), trait2+1)
TMBdata <- tibble::lst(Q_template, tree = p1, d = 2, trait_values = traits)

pars <- list(trans_rates=c(0.25, 0.75))
prune_nll(pars)

ff <- RTMB::MakeADFun(func = prune_nll,
                      parameters = list(trans_rates = trans_rates), silent = TRUE)

## BMB: Kristensen et al claim nlminb works better for the problems they tried
fit_2by2 <- nlminb(ff$par, ff$fn, ff$gr)

# make_myfun <- function(data) {
#  make_myfun <- function(fun, data) {
#      attach(data)
#    MakeADFun(fun, pars)
# }
```

```{r test1}
traits <- with(as.data.frame(primate.discrete2), 1 + (trait1*2 + trait2))
TMBdata <- tibble::lst(Q_template = Q_template4,
                       tree = p1, d = 4, trait_values = traits)

pars <- list(trans_rates = traits)
prune_nll(pars)
ff4 <- RTMB::MakeADFun(func = prune_nll,
                      parameters = list(trans_rates = trans_rates), silent = TRUE)

fit_4by4 <- suppressWarnings(
  with(ff4, nlminb(par, fn, gr))
)
fit_4by4_optim <- with(ff4, optim(par, fn, gr, method = "BFGS"))
fit_4by4_NM <- with(ff4, optim(par, fn, gr, method = "Nelder-Mead",
                               control = list(maxit = 10000)))


with(ff4$env, ff4$fn(last.par.best))
with(ff4$env, ff4$gr(last.par.best))
```

## bigger transition matrices

```{r corHMM-test}
library(corHMM)
data(primates)
head(primates)
with(primates, corHMM(tree, trait, rate.cat = 1))
```


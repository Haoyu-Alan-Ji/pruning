---
title: "parametric bootstrap in real data"
author: "Haoyu Ji"
format: 
  html:
    self-contained: true
    code-fold: true
    code-summary: "Code"
bibliography: ../pruning.bib
csl: ../reflist2.csl
date: today
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
setwd(here::here())
```

```{r pkgs, include=FALSE, message = FALSE, warning=FALSE}
## https://github.com/bbolker/corHMM/blob/bolker_clean/misc/test_RTMB.R
## remotes::install_github("bbolker/corHMM", ref = "bolker_clean")
library(Matrix)
library(ape)
library(tidyverse); theme_set(theme_bw())
library(expm)
library(RTMB)
```

```{r seed, include=FALSE}
set.seed(427)
```

```{r funs, message = FALSE, warning=FALSE}
#| code-fold: false
source(here::here("R", "Q_template.R"))
source(here::here("R", "getinfo.R"))
source(here::here("R", "realtree.R"))
```

- In Q_template.R, Q_template can be used to generate transit matrix Q, simfun can output trees of arbitrary length and specify the desired trait matrix for generation (currently only supports binary strates).
- In getinfo.R, sumfun can run corHMM quietly, allowing you to choose between using RTMB or the original version, and extract information (computation time, log-likelihood, and predicted values, etc.).
- RealTree.R provides a method for conducting large-scale benchmarking by sampling from real-world datasets.

The dataset is from ray-fish dataset (@eckert_parental_nodate)
```{r realdat}
#| code-summary: "import data"
fish_traits <- read.csv(here::here('data', "binaryTraitData.csv"))
fish_tree   <- readRDS(here::here('data', "treeSingle.rds"))
```

```{r clean3traits}
#| code-summary: "data cleaning"
ctraits <- fish_traits[fish_traits$species %in% fish_tree$tip.label, ]

ctraits <- ctraits[match(fish_tree$tip.label, ctraits$species), ]

c_traits <- data.frame(
  Species = ctraits$species,
  ag = ctraits$ag,
  care = ctraits$care,
  spawning = ctraits$spawning
)

c_traits <- c_traits[!is.na(c_traits$care) & !is.na(c_traits$spawning), ]
c_tree <- drop.tip(fish_tree, setdiff(fish_tree$tip.label, c_traits$Species))

c_traits <- c_traits[match(c_tree$tip.label, c_traits$Species), ]
```

```{r getdat, eval = FALSE}
#| code-summary: "resampling and runing"
ntaxvec <- as.numeric(45:234)

dd <- expand.grid(seed = 101:104, ntaxa  = ntaxvec, ntrait = 3, model = "ARD", rate.cat = 1) |>
  transform(model = as.character(model))

res <- list()

for (i in seq_len(nrow(dd))) {
  cat(sprintf("\rRunning %d/%d", i, nrow(dd)))
  flush.console()

  ntaxa_i <- dd$ntaxa[i]
  sub <- sample_subtree(tree = c_tree, traits = c_traits, ntaxa  = ntaxa_i)

  args_i <- c(
    as.list(dd[i, ]),   
    list(
      traitMatrix = sub$traits, 
      realtree = sub$tree 
    )
  )

  res[[i]] <- do.call(sumfun, args_i)
}

res_df <- do.call(rbind, res)
saveRDS(res_df, file = here::here("data", "trait3_subtree.rds"))
```


```{r dat}
#| code-summary: "importing rds"
dd <- readRDS(here::here("data", "trait3_subtree.rds"))
if (!is.data.frame(dd)) dd <- as.data.frame(t(dd))
```

RTMB (@RTMBIntro) shows a slight improvement in the calculation of negative log-likelihood (this is more noticeable when the tree length is small). When calculating larger trees, RTMB also demonstrates more stable computational performance, which can be observed through the smaller variance in computation time.

```{r loglik}
#| code-summary: "loglik boxplot"
dd$ldiff <- dd$RTMB_loglik - dd$orig_loglik

dd$ntaxa_bin <- cut(
  dd$ntaxa,
  breaks = c(0, 60, 100, 150, 250),
  labels = c("≤60", "61–100", "101–150", "151+")
)

ggplot(dd, aes(x = ntaxa_bin, y = ldiff, fill = model)) +
  geom_boxplot() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(
    x = "Number of taxa (binned)",
    y = "RTMB_loglik - orig_loglik",
    fill = "Model"
  ) +
  theme_minimal()
```

```{r ddtb}
#| code-summary: "visualize both loglik and time"
ddtb <- dd |>
  transmute(
    seed, ntaxa, ntrait, model,
    ldiff,
    opt_RTMB = RTMB_opt.time,
    opt_orig = orig_opt.time,
    tot_RTMB = RTMB_tot.time,
    tot_orig = orig_tot.time
  ) |>
  pivot_longer(
    cols = c(opt_RTMB, opt_orig, tot_RTMB, tot_orig),
    names_to      = c("type", "method"),
    names_pattern = "(opt|tot)_(RTMB|orig)",
    values_to     = "value"
  ) |>
  mutate(
    type   = factor(type,   levels = c("opt", "tot")),
    method = factor(method, levels = c("orig", "RTMB")),

    good = case_when(
      is.na(ldiff) ~ NA_character_,
      abs(ldiff) < 1e-6 ~ "OK",  
      ldiff < 0 ~ "RTMB",  
      ldiff > 0 ~ "orig"
    ),
    good = factor(good, levels = c("OK", "orig", "RTMB"))
  )

ddtb_win <- bind_rows(
  ddtb |> filter(good %in% c("orig", "RTMB"), as.character(method) == as.character(good))
)
```

```{r}
#| code-summary: "smaller nll scatter plot"
ggplot(
  ddtb_win,
  aes(x = ntaxa, y = value)
) +
  geom_point(aes(colour = good, size = abs(ldiff))) +
  scale_x_log10() +
  scale_y_log10() +
  scale_colour_manual(
    values = c(
      "OK"   = adjustcolor("grey", alpha.f = 0.2),
      "orig" = "#377EB8",
      "RTMB" = "#E41A1C"
    ),
    na.value = "black"
  ) +
  scale_size(range = c(0.5, 3), guide = "none") +
  facet_wrap(~ type, nrow = 1) +
  labs(
    x = "Number of taxa",
    y = "time of better nll (opt)",
    colour = "smaller nll"
  ) +
  theme_minimal()
```

```{r together, message = FALSE, warning=FALSE}
#| code-summary: "We can check all computing results"
ggplot(ddtb, aes(x = ntaxa, y = value, colour = method)) +
  geom_point(alpha = 0.5, aes(shape = factor(ntrait))) +
  scale_x_log10() +
  scale_y_log10() +
  facet_wrap(~ type, scales = "free_y") +
  geom_smooth(
    aes(linetype = factor(ntrait)),
    method = "lm",  
    se = FALSE,
    size = 0.8
  ) +
  labs(
    x = "Number of taxa",
    y = "time",
    colour   = "method",
    shape    = "ntrait",
    linetype = "ntrait"
  ) +
  theme_minimal()
```

The data was grouped according to ntaxa, and the median was used to represent the ratio of RTMB and orig_corHMM computation times under normal circumstances. There was approximately a 50 to 100-fold improvement, and this ratio increased with increasing ntaxa.
```{r prop, message = FALSE, warning=FALSE}
#| code-summary: "propotion"
dd$speedup_tot  <- dd$orig_tot.time / dd$RTMB_tot.time
dd$speedup_opt  <- dd$orig_opt.time / dd$RTMB_opt.time

speed_sum <- dd |> 
  group_by(ntaxa, model) |>
  summarise(
    med_speedup_tot = median(speedup_tot, na.rm = TRUE),
    med_speedup_opt = median(speedup_opt, na.rm = TRUE),
    .groups = "drop"
  ) |>
  pivot_longer(
    cols = starts_with("med_speedup_"),
    names_to = "type",
    values_to = "med_speedup"
  )

ggplot(speed_sum, aes(x = ntaxa, y = med_speedup, colour = model)) +
  geom_line() +
  geom_point() +
  geom_smooth(
    aes(group = 1, colour = NULL), 
    method = "loess",
    se = FALSE,
    linetype = "dashed"
  ) +
  facet_wrap(~ type, scales = "free_y") +
  labs(
    x = "Number of taxa",
    y = "Median speedup (orig / RTMB)",
    colour = "Model"
  ) +
  theme_minimal()
```